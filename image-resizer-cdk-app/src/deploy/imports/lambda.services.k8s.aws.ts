// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alias is the Schema for the Aliases API
 *
 * @schema Alias
 */
export class Alias extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alias"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.services.k8s.aws/v1alpha1',
    kind: 'Alias',
  }

  /**
   * Renders a Kubernetes manifest for "Alias".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AliasProps = {}): any {
    return {
      ...Alias.GVK,
      ...toJson_AliasProps(props),
    };
  }

  /**
   * Defines a "Alias" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AliasProps = {}) {
    super(scope, id, {
      ...Alias.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alias.GVK,
      ...toJson_AliasProps(resolved),
    };
  }
}

/**
 * Alias is the Schema for the Aliases API
 *
 * @schema Alias
 */
export interface AliasProps {
  /**
   * @schema Alias#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Alias#spec
   */
  readonly spec?: AliasSpec;

}

/**
 * Converts an object of type 'AliasProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasProps(obj: AliasProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AliasSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AliasSpec
 */
export interface AliasSpec {
  /**
   * A description of the alias.
   *
   * @schema AliasSpec#description
   */
  readonly description?: string;

  /**
   * The name of the Lambda function.
   * Name formats
   * * Function name - MyFunction.
   * * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
   * * Partial ARN - 123456789012:function:MyFunction.
   * The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
   *
   * @schema AliasSpec#functionName
   */
  readonly functionName: string;

  /**
   * The function version that the alias invokes.
   *
   * @schema AliasSpec#functionVersion
   */
  readonly functionVersion: string;

  /**
   * The name of the alias.
   *
   * @schema AliasSpec#name
   */
  readonly name: string;

  /**
   * The routing configuration (https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
   *
   * @schema AliasSpec#routingConfig
   */
  readonly routingConfig?: AliasSpecRoutingConfig;

}

/**
 * Converts an object of type 'AliasSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpec(obj: AliasSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'functionName': obj.functionName,
    'functionVersion': obj.functionVersion,
    'name': obj.name,
    'routingConfig': toJson_AliasSpecRoutingConfig(obj.routingConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The routing configuration (https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
 *
 * @schema AliasSpecRoutingConfig
 */
export interface AliasSpecRoutingConfig {
  /**
   * @schema AliasSpecRoutingConfig#additionalVersionWeights
   */
  readonly additionalVersionWeights?: { [key: string]: number };

}

/**
 * Converts an object of type 'AliasSpecRoutingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AliasSpecRoutingConfig(obj: AliasSpecRoutingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalVersionWeights': ((obj.additionalVersionWeights) === undefined) ? undefined : (Object.entries(obj.additionalVersionWeights).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CodeSigningConfig is the Schema for the CodeSigningConfigs API
 *
 * @schema CodeSigningConfig
 */
export class CodeSigningConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CodeSigningConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.services.k8s.aws/v1alpha1',
    kind: 'CodeSigningConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CodeSigningConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CodeSigningConfigProps = {}): any {
    return {
      ...CodeSigningConfig.GVK,
      ...toJson_CodeSigningConfigProps(props),
    };
  }

  /**
   * Defines a "CodeSigningConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CodeSigningConfigProps = {}) {
    super(scope, id, {
      ...CodeSigningConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CodeSigningConfig.GVK,
      ...toJson_CodeSigningConfigProps(resolved),
    };
  }
}

/**
 * CodeSigningConfig is the Schema for the CodeSigningConfigs API
 *
 * @schema CodeSigningConfig
 */
export interface CodeSigningConfigProps {
  /**
   * @schema CodeSigningConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CodeSigningConfigSpec defines the desired state of CodeSigningConfig.
   * Details about a Code signing configuration (https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
   *
   * @schema CodeSigningConfig#spec
   */
  readonly spec?: CodeSigningConfigSpec;

}

/**
 * Converts an object of type 'CodeSigningConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigProps(obj: CodeSigningConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CodeSigningConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CodeSigningConfigSpec defines the desired state of CodeSigningConfig.
 * Details about a Code signing configuration (https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
 *
 * @schema CodeSigningConfigSpec
 */
export interface CodeSigningConfigSpec {
  /**
   * Signing profiles for this code signing configuration.
   *
   * @schema CodeSigningConfigSpec#allowedPublishers
   */
  readonly allowedPublishers: CodeSigningConfigSpecAllowedPublishers;

  /**
   * The code signing policies define the actions to take if the validation checks fail.
   *
   * @schema CodeSigningConfigSpec#codeSigningPolicies
   */
  readonly codeSigningPolicies?: CodeSigningConfigSpecCodeSigningPolicies;

  /**
   * Descriptive name for this code signing configuration.
   *
   * @schema CodeSigningConfigSpec#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpec(obj: CodeSigningConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPublishers': toJson_CodeSigningConfigSpecAllowedPublishers(obj.allowedPublishers),
    'codeSigningPolicies': toJson_CodeSigningConfigSpecCodeSigningPolicies(obj.codeSigningPolicies),
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Signing profiles for this code signing configuration.
 *
 * @schema CodeSigningConfigSpecAllowedPublishers
 */
export interface CodeSigningConfigSpecAllowedPublishers {
  /**
   * @schema CodeSigningConfigSpecAllowedPublishers#signingProfileVersionARNs
   */
  readonly signingProfileVersionArNs?: string[];

}

/**
 * Converts an object of type 'CodeSigningConfigSpecAllowedPublishers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecAllowedPublishers(obj: CodeSigningConfigSpecAllowedPublishers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signingProfileVersionARNs': obj.signingProfileVersionArNs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The code signing policies define the actions to take if the validation checks fail.
 *
 * @schema CodeSigningConfigSpecCodeSigningPolicies
 */
export interface CodeSigningConfigSpecCodeSigningPolicies {
  /**
   * @schema CodeSigningConfigSpecCodeSigningPolicies#untrustedArtifactOnDeployment
   */
  readonly untrustedArtifactOnDeployment?: string;

}

/**
 * Converts an object of type 'CodeSigningConfigSpecCodeSigningPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodeSigningConfigSpecCodeSigningPolicies(obj: CodeSigningConfigSpecCodeSigningPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'untrustedArtifactOnDeployment': obj.untrustedArtifactOnDeployment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * EventSourceMapping is the Schema for the EventSourceMappings API
 *
 * @schema EventSourceMapping
 */
export class EventSourceMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSourceMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.services.k8s.aws/v1alpha1',
    kind: 'EventSourceMapping',
  }

  /**
   * Renders a Kubernetes manifest for "EventSourceMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSourceMappingProps = {}): any {
    return {
      ...EventSourceMapping.GVK,
      ...toJson_EventSourceMappingProps(props),
    };
  }

  /**
   * Defines a "EventSourceMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSourceMappingProps = {}) {
    super(scope, id, {
      ...EventSourceMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSourceMapping.GVK,
      ...toJson_EventSourceMappingProps(resolved),
    };
  }
}

/**
 * EventSourceMapping is the Schema for the EventSourceMappings API
 *
 * @schema EventSourceMapping
 */
export interface EventSourceMappingProps {
  /**
   * @schema EventSourceMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSourceMappingSpec defines the desired state of EventSourceMapping.
   *
   * @schema EventSourceMapping#spec
   */
  readonly spec?: EventSourceMappingSpec;

}

/**
 * Converts an object of type 'EventSourceMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingProps(obj: EventSourceMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSourceMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSourceMappingSpec defines the desired state of EventSourceMapping.
 *
 * @schema EventSourceMappingSpec
 */
export interface EventSourceMappingSpec {
  /**
   * The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
   * * Amazon Kinesis - Default 100. Max 10,000.
   * * Amazon DynamoDB Streams - Default 100. Max 1,000.
   * * Amazon Simple Queue Service - Default 10. For standard queues the max    is 10,000. For FIFO queues the max is 10.
   * * Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.
   * * Self-Managed Apache Kafka - Default 100. Max 10,000.
   *
   * @schema EventSourceMappingSpec#batchSize
   */
  readonly batchSize?: number;

  /**
   * (Streams only) If the function returns an error, split the batch in two and retry.
   *
   * @schema EventSourceMappingSpec#bisectBatchOnFunctionError
   */
  readonly bisectBatchOnFunctionError?: boolean;

  /**
   * (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
   *
   * @schema EventSourceMappingSpec#destinationConfig
   */
  readonly destinationConfig?: EventSourceMappingSpecDestinationConfig;

  /**
   * When true, the event source mapping is active. When false, Lambda pauses polling and invocation.
   * Default: True
   *
   * @schema EventSourceMappingSpec#enabled
   */
  readonly enabled?: boolean;

  /**
   * The Amazon Resource Name (ARN) of the event source.
   * * Amazon Kinesis - The ARN of the data stream or a stream consumer.
   * * Amazon DynamoDB Streams - The ARN of the stream.
   * * Amazon Simple Queue Service - The ARN of the queue.
   * * Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
   *
   * @schema EventSourceMappingSpec#eventSourceARN
   */
  readonly eventSourceArn?: string;

  /**
   * The name of the Lambda function.
   * Name formats
   * * Function name - MyFunction.
   * * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
   * * Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
   * * Partial ARN - 123456789012:function:MyFunction.
   * The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
   *
   * @schema EventSourceMappingSpec#functionName
   */
  readonly functionName: string;

  /**
   * (Streams only) A list of current response type enums applied to the event source mapping.
   *
   * @schema EventSourceMappingSpec#functionResponseTypes
   */
  readonly functionResponseTypes?: string[];

  /**
   * (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
   * Default: 0
   * Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
   *
   * @schema EventSourceMappingSpec#maximumBatchingWindowInSeconds
   */
  readonly maximumBatchingWindowInSeconds?: number;

  /**
   * (Streams only) Discard records older than the specified age. The default value is infinite (-1).
   *
   * @schema EventSourceMappingSpec#maximumRecordAgeInSeconds
   */
  readonly maximumRecordAgeInSeconds?: number;

  /**
   * (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
   *
   * @schema EventSourceMappingSpec#maximumRetryAttempts
   */
  readonly maximumRetryAttempts?: number;

  /**
   * (Streams only) The number of batches to process from each shard concurrently.
   *
   * @schema EventSourceMappingSpec#parallelizationFactor
   */
  readonly parallelizationFactor?: number;

  /**
   * (MQ) The name of the Amazon MQ broker destination queue to consume.
   *
   * @schema EventSourceMappingSpec#queues
   */
  readonly queues?: string[];

  /**
   * The Self-Managed Apache Kafka cluster to send records.
   *
   * @schema EventSourceMappingSpec#selfManagedEventSource
   */
  readonly selfManagedEventSource?: EventSourceMappingSpecSelfManagedEventSource;

  /**
   * An array of authentication protocols or VPC components required to secure your event source.
   *
   * @schema EventSourceMappingSpec#sourceAccessConfigurations
   */
  readonly sourceAccessConfigurations?: EventSourceMappingSpecSourceAccessConfigurations[];

  /**
   * The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams sources. AT_TIMESTAMP is only supported for Amazon Kinesis streams.
   *
   * @schema EventSourceMappingSpec#startingPosition
   */
  readonly startingPosition?: string;

  /**
   * With StartingPosition set to AT_TIMESTAMP, the time from which to start reading.
   *
   * @schema EventSourceMappingSpec#startingPositionTimestamp
   */
  readonly startingPositionTimestamp?: Date;

  /**
   * The name of the Kafka topic.
   *
   * @schema EventSourceMappingSpec#topics
   */
  readonly topics?: string[];

  /**
   * (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
   *
   * @schema EventSourceMappingSpec#tumblingWindowInSeconds
   */
  readonly tumblingWindowInSeconds?: number;

}

/**
 * Converts an object of type 'EventSourceMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpec(obj: EventSourceMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSize': obj.batchSize,
    'bisectBatchOnFunctionError': obj.bisectBatchOnFunctionError,
    'destinationConfig': toJson_EventSourceMappingSpecDestinationConfig(obj.destinationConfig),
    'enabled': obj.enabled,
    'eventSourceARN': obj.eventSourceArn,
    'functionName': obj.functionName,
    'functionResponseTypes': obj.functionResponseTypes?.map(y => y),
    'maximumBatchingWindowInSeconds': obj.maximumBatchingWindowInSeconds,
    'maximumRecordAgeInSeconds': obj.maximumRecordAgeInSeconds,
    'maximumRetryAttempts': obj.maximumRetryAttempts,
    'parallelizationFactor': obj.parallelizationFactor,
    'queues': obj.queues?.map(y => y),
    'selfManagedEventSource': toJson_EventSourceMappingSpecSelfManagedEventSource(obj.selfManagedEventSource),
    'sourceAccessConfigurations': obj.sourceAccessConfigurations?.map(y => toJson_EventSourceMappingSpecSourceAccessConfigurations(y)),
    'startingPosition': obj.startingPosition,
    'startingPositionTimestamp': obj.startingPositionTimestamp?.toISOString(),
    'topics': obj.topics?.map(y => y),
    'tumblingWindowInSeconds': obj.tumblingWindowInSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
 *
 * @schema EventSourceMappingSpecDestinationConfig
 */
export interface EventSourceMappingSpecDestinationConfig {
  /**
   * A destination for events that failed processing.
   *
   * @schema EventSourceMappingSpecDestinationConfig#onFailure
   */
  readonly onFailure?: EventSourceMappingSpecDestinationConfigOnFailure;

  /**
   * A destination for events that were processed successfully.
   *
   * @schema EventSourceMappingSpecDestinationConfig#onSuccess
   */
  readonly onSuccess?: EventSourceMappingSpecDestinationConfigOnSuccess;

}

/**
 * Converts an object of type 'EventSourceMappingSpecDestinationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecDestinationConfig(obj: EventSourceMappingSpecDestinationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onFailure': toJson_EventSourceMappingSpecDestinationConfigOnFailure(obj.onFailure),
    'onSuccess': toJson_EventSourceMappingSpecDestinationConfigOnSuccess(obj.onSuccess),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Self-Managed Apache Kafka cluster to send records.
 *
 * @schema EventSourceMappingSpecSelfManagedEventSource
 */
export interface EventSourceMappingSpecSelfManagedEventSource {
  /**
   * @schema EventSourceMappingSpecSelfManagedEventSource#endpoints
   */
  readonly endpoints?: { [key: string]: string[] };

}

/**
 * Converts an object of type 'EventSourceMappingSpecSelfManagedEventSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecSelfManagedEventSource(obj: EventSourceMappingSpecSelfManagedEventSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': ((obj.endpoints) === undefined) ? undefined : (Object.entries(obj.endpoints).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
 *
 * @schema EventSourceMappingSpecSourceAccessConfigurations
 */
export interface EventSourceMappingSpecSourceAccessConfigurations {
  /**
   * @schema EventSourceMappingSpecSourceAccessConfigurations#type_
   */
  readonly type?: string;

  /**
   * @schema EventSourceMappingSpecSourceAccessConfigurations#uRI
   */
  readonly uRi?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecSourceAccessConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecSourceAccessConfigurations(obj: EventSourceMappingSpecSourceAccessConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type_': obj.type,
    'uRI': obj.uRi,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A destination for events that failed processing.
 *
 * @schema EventSourceMappingSpecDestinationConfigOnFailure
 */
export interface EventSourceMappingSpecDestinationConfigOnFailure {
  /**
   * @schema EventSourceMappingSpecDestinationConfigOnFailure#destination
   */
  readonly destination?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecDestinationConfigOnFailure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecDestinationConfigOnFailure(obj: EventSourceMappingSpecDestinationConfigOnFailure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A destination for events that were processed successfully.
 *
 * @schema EventSourceMappingSpecDestinationConfigOnSuccess
 */
export interface EventSourceMappingSpecDestinationConfigOnSuccess {
  /**
   * @schema EventSourceMappingSpecDestinationConfigOnSuccess#destination
   */
  readonly destination?: string;

}

/**
 * Converts an object of type 'EventSourceMappingSpecDestinationConfigOnSuccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSourceMappingSpecDestinationConfigOnSuccess(obj: EventSourceMappingSpecDestinationConfigOnSuccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Function is the Schema for the Functions API
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'lambda.services.k8s.aws/v1alpha1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps = {}): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps = {}) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function.
   *
   * @schema Function#spec
   */
  readonly spec?: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function.
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * The instruction set architecture that the function supports. Enter a string array with one of the valid values. The default value is x86_64.
   *
   * @schema FunctionSpec#architectures
   */
  readonly architectures?: string[];

  /**
   * The code for the function.
   *
   * @schema FunctionSpec#code
   */
  readonly code: FunctionSpecCode;

  /**
   * To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
   *
   * @schema FunctionSpec#codeSigningConfigARN
   */
  readonly codeSigningConfigArn?: string;

  /**
   * A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
   *
   * @schema FunctionSpec#deadLetterConfig
   */
  readonly deadLetterConfig?: FunctionSpecDeadLetterConfig;

  /**
   * A description of the function.
   *
   * @schema FunctionSpec#description
   */
  readonly description?: string;

  /**
   * Environment variables that are accessible from function code during execution.
   *
   * @schema FunctionSpec#environment
   */
  readonly environment?: FunctionSpecEnvironment;

  /**
   * Connection settings for an Amazon EFS file system.
   *
   * @schema FunctionSpec#fileSystemConfigs
   */
  readonly fileSystemConfigs?: FunctionSpecFileSystemConfigs[];

  /**
   * The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Programming Model (https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html).
   *
   * @schema FunctionSpec#handler
   */
  readonly handler?: string;

  /**
   * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
   *
   * @schema FunctionSpec#imageConfig
   */
  readonly imageConfig?: FunctionSpecImageConfig;

  /**
   * The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment variables. If it's not provided, Lambda uses a default service key.
   *
   * @schema FunctionSpec#kmsKeyARN
   */
  readonly kmsKeyArn?: string;

  /**
   * The amount of memory available to the function (https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
   *
   * @schema FunctionSpec#memorySize
   */
  readonly memorySize?: number;

  /**
   * The name of the Lambda function.
   * Name formats
   * * Function name - my-function.
   * * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
   * * Partial ARN - 123456789012:function:my-function.
   * The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
   *
   * @schema FunctionSpec#name
   */
  readonly name: string;

  /**
   * The type of deployment package. Set to Image for container image and set Zip for ZIP archive.
   *
   * @schema FunctionSpec#packageType
   */
  readonly packageType?: string;

  /**
   * Set to true to publish the first version of the function during creation.
   *
   * @schema FunctionSpec#publish
   */
  readonly publish?: boolean;

  /**
   * The number of simultaneous executions to reserve for the function.
   *
   * @schema FunctionSpec#reservedConcurrentExecutions
   */
  readonly reservedConcurrentExecutions?: number;

  /**
   * The Amazon Resource Name (ARN) of the function's execution role.
   *
   * @schema FunctionSpec#role
   */
  readonly role: string;

  /**
   * The identifier of the function's runtime (https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).
   *
   * @schema FunctionSpec#runtime
   */
  readonly runtime?: string;

  /**
   * A list of tags (https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
   *
   * @schema FunctionSpec#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For additional information, see Lambda execution environment (https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
   *
   * @schema FunctionSpec#timeout
   */
  readonly timeout?: number;

  /**
   * Set Mode to Active to sample and trace a subset of incoming requests with X-Ray (https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
   *
   * @schema FunctionSpec#tracingConfig
   */
  readonly tracingConfig?: FunctionSpecTracingConfig;

  /**
   * For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
   *
   * @schema FunctionSpec#vpcConfig
   */
  readonly vpcConfig?: FunctionSpecVpcConfig;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'architectures': obj.architectures?.map(y => y),
    'code': toJson_FunctionSpecCode(obj.code),
    'codeSigningConfigARN': obj.codeSigningConfigArn,
    'deadLetterConfig': toJson_FunctionSpecDeadLetterConfig(obj.deadLetterConfig),
    'description': obj.description,
    'environment': toJson_FunctionSpecEnvironment(obj.environment),
    'fileSystemConfigs': obj.fileSystemConfigs?.map(y => toJson_FunctionSpecFileSystemConfigs(y)),
    'handler': obj.handler,
    'imageConfig': toJson_FunctionSpecImageConfig(obj.imageConfig),
    'kmsKeyARN': obj.kmsKeyArn,
    'memorySize': obj.memorySize,
    'name': obj.name,
    'packageType': obj.packageType,
    'publish': obj.publish,
    'reservedConcurrentExecutions': obj.reservedConcurrentExecutions,
    'role': obj.role,
    'runtime': obj.runtime,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'tracingConfig': toJson_FunctionSpecTracingConfig(obj.tracingConfig),
    'vpcConfig': toJson_FunctionSpecVpcConfig(obj.vpcConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The code for the function.
 *
 * @schema FunctionSpecCode
 */
export interface FunctionSpecCode {
  /**
   * @schema FunctionSpecCode#imageURI
   */
  readonly imageUri?: string;

  /**
   * @schema FunctionSpecCode#s3Bucket
   */
  readonly s3Bucket?: string;

  /**
   * @schema FunctionSpecCode#s3Key
   */
  readonly s3Key?: string;

  /**
   * @schema FunctionSpecCode#s3ObjectVersion
   */
  readonly s3ObjectVersion?: string;

  /**
   * @schema FunctionSpecCode#zipFile
   */
  readonly zipFile?: string;

}

/**
 * Converts an object of type 'FunctionSpecCode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecCode(obj: FunctionSpecCode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageURI': obj.imageUri,
    's3Bucket': obj.s3Bucket,
    's3Key': obj.s3Key,
    's3ObjectVersion': obj.s3ObjectVersion,
    'zipFile': obj.zipFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead Letter Queues (https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq).
 *
 * @schema FunctionSpecDeadLetterConfig
 */
export interface FunctionSpecDeadLetterConfig {
  /**
   * @schema FunctionSpecDeadLetterConfig#targetARN
   */
  readonly targetArn?: string;

}

/**
 * Converts an object of type 'FunctionSpecDeadLetterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecDeadLetterConfig(obj: FunctionSpecDeadLetterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetARN': obj.targetArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Environment variables that are accessible from function code during execution.
 *
 * @schema FunctionSpecEnvironment
 */
export interface FunctionSpecEnvironment {
  /**
   * @schema FunctionSpecEnvironment#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'FunctionSpecEnvironment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecEnvironment(obj: FunctionSpecEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the connection between a Lambda function and an Amazon EFS file system (https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
 *
 * @schema FunctionSpecFileSystemConfigs
 */
export interface FunctionSpecFileSystemConfigs {
  /**
   * @schema FunctionSpecFileSystemConfigs#arn
   */
  readonly arn?: string;

  /**
   * @schema FunctionSpecFileSystemConfigs#localMountPath
   */
  readonly localMountPath?: string;

}

/**
 * Converts an object of type 'FunctionSpecFileSystemConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecFileSystemConfigs(obj: FunctionSpecFileSystemConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'localMountPath': obj.localMountPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container image configuration values (https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
 *
 * @schema FunctionSpecImageConfig
 */
export interface FunctionSpecImageConfig {
  /**
   * @schema FunctionSpecImageConfig#command
   */
  readonly command?: string[];

  /**
   * @schema FunctionSpecImageConfig#entryPoint
   */
  readonly entryPoint?: string[];

  /**
   * @schema FunctionSpecImageConfig#workingDirectory
   */
  readonly workingDirectory?: string;

}

/**
 * Converts an object of type 'FunctionSpecImageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecImageConfig(obj: FunctionSpecImageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
    'entryPoint': obj.entryPoint?.map(y => y),
    'workingDirectory': obj.workingDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set Mode to Active to sample and trace a subset of incoming requests with X-Ray (https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
 *
 * @schema FunctionSpecTracingConfig
 */
export interface FunctionSpecTracingConfig {
  /**
   * @schema FunctionSpecTracingConfig#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'FunctionSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecTracingConfig(obj: FunctionSpecTracingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more information, see VPC Settings (https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
 *
 * @schema FunctionSpecVpcConfig
 */
export interface FunctionSpecVpcConfig {
  /**
   * @schema FunctionSpecVpcConfig#securityGroupIDs
   */
  readonly securityGroupIDs?: string[];

  /**
   * @schema FunctionSpecVpcConfig#subnetIDs
   */
  readonly subnetIDs?: string[];

}

/**
 * Converts an object of type 'FunctionSpecVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecVpcConfig(obj: FunctionSpecVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIDs': obj.securityGroupIDs?.map(y => y),
    'subnetIDs': obj.subnetIDs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

